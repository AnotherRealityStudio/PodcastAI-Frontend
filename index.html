<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>STL City SC Tools</title>
  <!-- Simple web UI for exercising the API endpoints provided by the server -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.1/font/bootstrap-icons.css">
  <style>
    body {
      background: #f6f7fb;
    }
    section {
      background: #fff;
      border-radius: .5rem;
      box-shadow: 0 0.25rem 0.5rem rgba(0,0,0,0.1);
      padding: 1.5rem;
      margin-bottom: 2rem;
    }
    pre {
      white-space: pre-wrap;
    }
    .dialogue-entry {
      background: #f8f9fa;
    }
  </style>
</head>
<body>
  <div class="container my-4">
    <h1 class="text-center mb-4">STL City SC Tools</h1>

    <div class="mb-4">
      <label for="apiBase" class="form-label">API Base URL</label>
      <input id="apiBase" type="text" class="form-control" value="https://arstesting.onrender.com">
    </div>

    <div class="mb-4">
      <label for="openaiKey" class="form-label">OpenAI API Key</label>
      <input id="openaiKey" type="password" class="form-control" placeholder="sk-...">
    </div>
    <div class="mb-4">
      <label for="geminiKey" class="form-label">Gemini API Key</label>
      <input id="geminiKey" type="password" class="form-control" placeholder="Enter Gemini key">
    </div>
    <div class="mb-4">
      <label for="perplexityKey" class="form-label">Perplexity API Key (optional)</label>
      <input id="perplexityKey" type="password" class="form-control" placeholder="Enter Perplexity key (optional)">
    </div>

    <div id="episodeWrapper" class="p-3 mb-4 border border-info rounded" style="background:#e8f8ff;">
    <section id="latest-section">
      <h2 class="h4">Latest STL City SC Post <small class="text-muted">(/stlcitysc/latest-post)</small></h2>
      <div class="input-group mb-2" style="max-width: 200px;">
        <span class="input-group-text">Pages</span>
        <input id="latestPages" type="number" class="form-control" min="1" value="1">
      </div>
      <button id="fetchLatestBtn" class="btn btn-info mb-2">
        <i class="bi bi-newspaper"></i> Fetch Latest
      </button>
      <div id="latestPost" class="row g-2"></div>
    </section>
    <section id="episode-section">
      <h2 class="h4">Generate Episode <small class="text-muted">(/stlcitysc/generate-episode)</small></h2>
      <div class="mb-2">
        <label class="form-label">Article IDs (comma or space separated)</label>
        <input id="epArticleId" type="text" class="form-control">
      </div>
      <div class="mb-2">
        <label class="form-label">System Prompt</label>
        <select id="epPromptSelect" class="form-select"></select>
      </div>
      <div class="mb-2">
        <label class="form-label">Season Context</label>
        <select id="epSeasonSelect" class="form-select"></select>
      </div>
      <div class="row g-2 mb-3">
        <div class="col">
          <label class="form-label">Host A Name</label>
          <input id="epHostAName" class="form-control" value="Kevin">
        </div>
        <div class="col">
          <label class="form-label">Host A Voice</label>
            <select id="epHostAVoice" class="form-select">
              <option>Zephyr</option>
              <option>Puck</option>
              <option>Charon</option>
              <option>Kore</option>
              <option>Fenrir</option>
              <option>Leda</option>
              <option>Orus</option>
              <option>Aoede</option>
              <option>Callirrhoe</option>
              <option>Autonoe</option>
              <option>Enceladus</option>
              <option>Iapetus</option>
              <option>Umbriel</option>
              <option>Algieba</option>
              <option>Despina</option>
              <option>Erinome</option>
              <option>Algenib</option>
              <option>Rasalgethi</option>
              <option>Laomedeia</option>
              <option>Achernar</option>
              <option>Alnilam</option>
              <option>Schedar</option>
              <option>Gacrux</option>
              <option>Pulcherrima</option>
              <option selected>Achird</option>
              <option>Zubenelgenubi</option>
              <option>Vindemiatrix</option>
              <option>Sadachbia</option>
              <option>Sadaltager</option>
              <option>Sulafat</option>
            </select>
        </div>
      </div>
      <div class="row g-2 mb-3">
        <div class="col">
          <label class="form-label">Host B Name</label>
          <input id="epHostBName" class="form-control" value="Abby">
        </div>
        <div class="col">
          <label class="form-label">Host B Voice</label>
            <select id="epHostBVoice" class="form-select">
              <option>Zephyr</option>
              <option>Puck</option>
              <option>Charon</option>
              <option selected>Kore</option>
              <option>Fenrir</option>
              <option>Leda</option>
              <option>Orus</option>
              <option>Aoede</option>
              <option>Callirrhoe</option>
              <option>Autonoe</option>
              <option>Enceladus</option>
              <option>Iapetus</option>
              <option>Umbriel</option>
              <option>Algieba</option>
              <option>Despina</option>
              <option>Erinome</option>
              <option>Algenib</option>
              <option>Rasalgethi</option>
              <option>Laomedeia</option>
              <option>Achernar</option>
              <option>Alnilam</option>
              <option>Schedar</option>
              <option>Gacrux</option>
              <option>Pulcherrima</option>
              <option>Achird</option>
              <option>Zubenelgenubi</option>
              <option>Vindemiatrix</option>
              <option>Sadachbia</option>
              <option>Sadaltager</option>
              <option>Sulafat</option>
            </select>
      </div>
      </div>
      <div class="mb-2">
        <label class="form-label">Voice Model</label>
        <select id="epVoiceModel" class="form-select">
          <option value="gemini-2.5-flash-preview-tts" selected>Flash</option>
          <option value="gemini-2.5-pro-preview-tts">Pro</option>
        </select>
      </div>
      <div class="mb-2">
        <label class="form-label">Voice Context</label>
        <input id="epVoiceContext" class="form-control" value="Read aloud in a charismatic, fun, sports podcast tone.">
      </div>
      <div class="mb-2">
        <label class="form-label">Prompt Tweak</label>
        <textarea id="epPromptTweak" class="form-control" rows="2" placeholder="Extra instructions for the model (optional)"></textarea>
      </div>
      <button id="generateEpisodeBtn" class="btn btn-info mb-2">
        <i class="bi bi-broadcast"></i> Generate Episode
      </button>
      <div id="episodeProgress" class="progress mb-2" style="height:6px; display:none;">
        <div class="progress-bar progress-bar-striped progress-bar-animated" style="width:100%"></div>
      </div>
      <audio id="episodePlayer" class="w-100 mb-2" controls hidden></audio>
      <div id="episodeThumb" class="border rounded p-3 mb-2 text-center" style="max-height:300px; overflow:auto;" hidden>
        <img id="episodeImage" class="img-fluid" style="max-height:260px;">
      </div>
      <pre id="episodeScript" class="border rounded p-3 mb-2" style="max-height:300px; overflow:auto;"></pre>
      <pre id="episodeTranscript" class="border rounded p-3" style="max-height:300px; overflow:auto;"></pre>
    </section>
    </div>
    <h2 class="h4 mt-4">Toolbox</h2>
    <section id="podcast-section">
      <h2 class="h4">Podcast Script <small class="text-muted">(/stlcitysc/generate-script)</small></h2>
      <!-- Article IDs input for generate-script endpoint -->
      <div class="mb-2">
        <label class="form-label">Article IDs (comma or space separated)</label>
        <input id="scriptArticleId" type="text" class="form-control" placeholder="Enter Article IDs">
      </div>
      <div class="mb-2">
        <label class="form-label">System Prompt</label>
        <select id="scriptPromptSelect" class="form-select"></select>
      </div>
      <div class="mb-2">
        <label class="form-label">Season Context</label>
        <select id="scriptSeasonSelect" class="form-select"></select>
      </div>
      <div class="mb-2">
        <label class="form-label">Podcast Name</label>
        <input id="podcastName" class="form-control" value="The City Minute">
      </div>
      <div class="mb-2">
        <label class="form-label">Team Name</label>
        <input id="teamName" class="form-control" value="Saint Louis City SC">
      </div>
      <div class="mb-2">
        <label class="form-label">Tone</label>
        <input id="tone" class="form-control" value="Fun, charismatic, professional sports podcaster">
      </div>
      <div class="mb-2" style="max-width:150px;">
        <label class="form-label">Length (min)</label>
        <input id="lengthMin" type="number" class="form-control" value="4">
      </div>
      <div class="mb-2">
        <label class="form-label">Custom Intro</label>
        <textarea id="customIntro" class="form-control" rows="2">Welcome back to your City Minute, the official podcast of St Louis City SC, I’m your host, Kevin, and my lovely cohost with me today is Abby!</textarea>
      </div>
      <div class="mb-2">
        <label class="form-label">Custom Outro</label>
        <input id="customOutro" class="form-control" value="All for City!">
      </div>
      <div class="mb-2" style="display: none;">
        <label class="form-label">Prompt</label>
        <textarea id="scriptPrompt" class="form-control" rows="8">
St. Louis CITY SC earned a come-from-behind, 2-1 victory against Portland Timbers on Sunday night at Energizer Park. Despite dominating play early, St. Louis conceded the first goal of the match in the 19th minute. CITY SC rebounded just a few minutes into the second half, with Marcel Hartel roofing a strike to level the match. In the 67th minute, Hartel headed home a cross from Conrad Wallem to put CITY SC on top, earning his first career MLS brace. St. Louis is now a perfect 3-0-0 all-time in MLS home contests when Marcel Hartel finds the back of the net. CITY SC’s next match is a road showdown with FC Dallas on Saturday, July 19, at 7:30 p.m. CT at Toyota Stadium.
Postgame Notes
Marcel Hartel notched his first career MLS brace, bringing him to five total goals across all-competitions
When Hartel scores at home during the MLS regular season, CITY SC has an all-time record of 3-0-0
Hartel has six goal contributions (three goals, three assists) in four all-time matches against Portland Timbers across all competitions
Conrad Wallem notched his first career MLS assist
CITY SC has earned points in four of their last five home matches, going 2-1-2 (8 points) over that span
July 13, 2025 – Energizer Park (St. Louis, MO)
Goal-Scoring Plays
POR: David Da Costa (Santiago Moreno), 19th minute – David Da Costa scored with a right footed shot from the central position outside the box to the bottom right corner
STL: Marcel Hartel, 54th minute – Marcel Hartel with left footed shot from the center of the box to the top left corner.
STL: Marcel Hartel (Conrad Wallem), 67th minute – Marcel Hartel scored with header from the center of the box to the top left corner.
Scoring Summary
POR: David Da Costa (Santiago Moreno), 19’
STL: Marcel Hartel, 54’
STL: Marcel Hartel (Conrad Wallem), 67’
Misconduct Summary
POR: Joao Ortiz (caution), 59’
POR: Kevin Kelsy (caution), 64’
POR: Juan Mosquera (caution), 77’
POR: Kamal Miller (caution), 79’
STL: João Klauss (caution), 90’+2
STL: Jaziel Orozco (caution), 90’+3
Lineups
STL: GK Roman Bürki ©; D Tomas Totland, D Jake Girdwood-Reich, D Josh Yaro, D Jaziel Orozco (Kyle Hiebert, 90’+5), M Tomáš Ostrák (Eduard Löwen, 66’); M Conrad Wallem; M Cedric Teuchert (Akil Watts, 82’), M Marcel Hartel, M Célio Pompeu (Simon Becher, 67’); F João Klauss
Substitutes not used: GK Ben Lundt, D Jay Reid, D Joey Zalinsky, M Tyson Pearce, M Xande Silva
TOTAL SHOTS: 21; SHOTS ON GOAL: 8; FOULS: 9; OFFSIDES: 4; CORNER KICKS: 4; SAVES: 3
POR: GK Maxime Crepeau; D Kamal Miller ©, D Dario Zuparic (Gage Guerra, 75’), D Finn Surman, D Juan Mosquera; M David Da Costa, M David Ayala (Cristhian Paredes, 75’), M Jimer Fory (Ian Smith, 46’), M Santiago Moreno (Omir Fernandez, 65’), M Joao Ortiz (Diego Chara, 65’); F Kevin Kelsy
Substitutes not used: GK James Pantemis, F Felipe Mora, D Eric Miller
TOTAL SHOTS: 10; SHOTS ON GOAL: 4; FOULS: 10; OFFSIDES: 0; CORNER KICKS: 3; SAVES: 6
Referee: Ricardo Montero Araya
Assistant Referees: Logan Brown, Jeffrey Swartzel, Rubiel Vazquez
VAR: Jorge Gonzalez
AVAR: Fabio Tovar
Venue: Energizer Park
        </textarea>
      </div>
      <button id="generateScriptBtn" class="btn btn-info mb-2">
        <i class="bi bi-mic"></i> Generate Script
      </button>
      <pre id="podcastScript" class="border rounded p-3" style="max-height:300px; overflow:auto;"></pre>
      <div class="mb-2">
        <label class="form-label">Edit Instructions</label>
        <textarea id="editInstructions" class="form-control" rows="2" placeholder="Describe changes..."></textarea>
      </div>
      <button id="editScriptBtn" class="btn btn-secondary mb-2">
        <i class="bi bi-pencil"></i> Edit Script
      </button>
    </section>
    <section id="audio-section">
      <h2 class="h4">Audio Storage <small class="text-muted">(/audio-files)</small></h2>
      <div class="input-group mb-3">
        <input type="file" id="fileInput" class="form-control" accept=".mp3,.wav">
        <button id="uploadBtn" class="btn btn-success">
          <i class="bi bi-upload"></i> Upload
        </button>
        <button id="refreshFilesBtn" class="btn btn-secondary">
          <i class="bi bi-arrow-clockwise"></i> Refresh
        </button>
      </div>
      <ul id="fileList" class="list-group mb-3"></ul>
      <audio id="audioPlayer" class="w-100" controls hidden></audio>
    </section>
    <section id="mix-section">
      <h2 class="h4">Intro/Outro Mixer <small class="text-muted">(/intro-outro)</small></h2>
      <div class="mb-2">
        <label class="form-label">Intro File</label>
        <input type="file" id="introFile" class="form-control" accept=".mp3,.wav">
      </div>
      <div class="mb-2">
        <label class="form-label">Main Audio</label>
        <input type="file" id="mainFile" class="form-control" accept=".mp3,.wav">
      </div>
      <div class="mb-2">
        <label class="form-label">Outro File</label>
        <input type="file" id="outroFile" class="form-control" accept=".mp3,.wav">
      </div>
      <button id="mixBtn" class="btn btn-info mb-2">
        <i class="bi bi-music-note"></i> Combine
      </button>
      <audio id="mixPlayer" class="w-100" controls hidden></audio>
    </section>
    <section id="dialogue-section">
      <h2 class="h4">Text to Speech <small class="text-muted">(/dialogue)</small></h2>

      <div class="row g-2 mb-3">
        <div class="col">
          <label class="form-label">Speaker 1 Name</label>
          <input id="speaker1Name" class="form-control" value="Speaker1">
        </div>
        <div class="col">
          <label class="form-label">Speaker 1 Voice</label>
          <select id="speaker1Voice" class="form-select">
            <option>Zephyr</option>
            <option>Puck</option>
            <option>Charon</option>
            <option>Kore</option>
            <option>Fenrir</option>
            <option>Leda</option>
            <option>Orus</option>
            <option>Aoede</option>
            <option>Callirrhoe</option>
            <option>Autonoe</option>
            <option>Enceladus</option>
            <option>Iapetus</option>
            <option>Umbriel</option>
            <option>Algieba</option>
            <option>Despina</option>
            <option>Erinome</option>
            <option>Algenib</option>
            <option>Rasalgethi</option>
            <option>Laomedeia</option>
            <option>Achernar</option>
            <option>Alnilam</option>
            <option>Schedar</option>
            <option>Gacrux</option>
            <option>Pulcherrima</option>
            <option selected>Achird</option>
            <option>Zubenelgenubi</option>
            <option>Vindemiatrix</option>
            <option>Sadachbia</option>
            <option>Sadaltager</option>
            <option>Sulafat</option>
          </select>
        </div>
      </div>

      <div class="row g-2 mb-3">
        <div class="col">
          <label class="form-label">Speaker 2 Name</label>
          <input id="speaker2Name" class="form-control" value="Speaker2">
        </div>
        <div class="col">
          <label class="form-label">Speaker 2 Voice</label>
          <select id="speaker2Voice" class="form-select">
            <option>Zephyr</option>
            <option>Puck</option>
            <option>Charon</option>
            <option selected>Kore</option>
            <option>Fenrir</option>
            <option>Leda</option>
            <option>Orus</option>
            <option>Aoede</option>
            <option>Callirrhoe</option>
            <option>Autonoe</option>
            <option>Enceladus</option>
            <option>Iapetus</option>
            <option>Umbriel</option>
            <option>Algieba</option>
            <option>Despina</option>
            <option>Erinome</option>
            <option>Algenib</option>
            <option>Rasalgethi</option>
            <option>Laomedeia</option>
            <option>Achernar</option>
            <option>Alnilam</option>
            <option>Schedar</option>
            <option>Gacrux</option>
            <option>Pulcherrima</option>
            <option>Achird</option>
            <option>Zubenelgenubi</option>
            <option>Vindemiatrix</option>
            <option>Sadachbia</option>
            <option>Sadaltager</option>
            <option>Sulafat</option>
          </select>
        </div>
      </div>
      
      <div class="mb-3">
        <label class="form-label">Voice Model</label>
        <select id="voiceModel" class="form-select">
          <option value="gemini-2.5-flash-preview-tts" selected>Flash</option>
          <option value="gemini-2.5-pro-preview-tts">Pro</option>
        </select>
      </div>

      <div class="mb-3">
        <label class="form-label">Voice Context</label>
        <input id="voiceContext" class="form-control" value="Read aloud in a charismatic, fun, sports podcast tone.">
      </div>

      <div class="mb-3">
        <label class="form-label">Prompt</label>
        <textarea id="ttsPrompt" class="form-control" rows="3" placeholder="Enter text to speak..."></textarea>
      </div>

      <button id="dlgBtn" class="btn btn-primary mb-2">
        <i class="bi bi-play-circle"></i> Speak
      </button>
      <audio id="dlgPlayer" class="w-100" controls hidden></audio>
    </section>
    <section id="transcript-section">
      <h2 class="h4">Transcript <small class="text-muted">(/transcripts/:fileName)</small></h2>
      <div class="input-group mb-3">
        <input id="transcriptFile" type="text" class="form-control" placeholder="audio file name">
        <button id="getTranscriptBtn" class="btn btn-info">
          <i class="bi bi-file-earmark-text"></i> Fetch Transcript
        </button>
      </div>
      <div class="input-group mb-3">
        <input id="localTranscriptFile" type="file" class="form-control" accept=".mp3,.wav">
        <button id="uploadTranscriptBtn" class="btn btn-info">
          <i class="bi bi-upload"></i> Transcribe File
        </button>
      </div>
      <pre id="transcriptOut" class="border rounded p-3" style="max-height:300px; overflow:auto;"></pre>
    </section>
    <section id="thumbnail-section">
      <h2 class="h4">Episode Thumbnail <small class="text-muted">(/thumbnail)</small></h2>
      <textarea id="thumbPrompt" class="form-control mb-2" rows="2" placeholder="Image prompt"></textarea>
      <textarea id="thumbScript" class="form-control mb-2" rows="4" placeholder="Paste podcast script to auto-create a prompt"></textarea>
      <button id="generateThumbBtn" class="btn btn-info mb-2">
        <i class="bi bi-image"></i> Generate Image
      </button>
      <button id="generateThumbFromScriptBtn" class="btn btn-secondary mb-2">
        <i class="bi bi-magic"></i> From Script
      </button>
      <input id="thumbFileName" class="form-control mb-2" placeholder="File name (for update/delete)">
      <div class="mb-2">
        <button id="updateThumbBtn" class="btn btn-warning me-2">
          <i class="bi bi-arrow-repeat"></i> Update
        </button>
        <button id="deleteThumbBtn" class="btn btn-danger me-2">
          <i class="bi bi-trash"></i> Delete
        </button>
        <button id="listThumbsBtn" class="btn btn-secondary">
          <i class="bi bi-list"></i> List
        </button>
      </div>
      <div id="thumbList" class="border rounded p-3 mb-2 d-flex flex-wrap" style="max-height:200px; overflow:auto;"></div>
      <img id="thumbImage" class="img-fluid" style="max-height:300px;" hidden>
    </section>
    <section id="chat-section">
      <h2 class="h4">ChatGPT <small class="text-muted">(/chat)</small></h2>
      <textarea id="chatPrompt" class="form-control mb-2" rows="3" placeholder="Enter a prompt…"></textarea>
      <div class="row g-2 mb-2">
        <div class="col-auto">
          <label class="form-label">Temp</label>
          <input type="number" id="optTemp" class="form-control" min="0" max="1" step="0.1" value="0.7">
        </div>
        <div class="col-auto">
          <label class="form-label">Max Tokens</label>
          <input type="number" id="optMax" class="form-control" min="10" max="1000" value="300">
        </div>
      </div>
      <button id="sendChatBtn" class="btn btn-primary mb-2">
        <i class="bi bi-chat-dots"></i> Send
      </button>
      <pre id="chatReply" class="border rounded p-3" style="max-height:300px; overflow:auto;"></pre>
    </section>

    <section id="cost-estimator-section">
      <h2 class="h4">GPT Cost Estimator</h2>
      <div class="row g-2 mb-2">
        <div class="col-md-4">
          <label class="form-label">Model</label>
          <select id="costModel" class="form-select">
            <option value="gpt-4o">gpt-4o</option>
            <option value="gpt-4o-mini">gpt-4o-mini</option>
          </select>
        </div>
        <div class="col-md-4">
          <label class="form-label">Input Tokens</label>
          <input type="number" id="costInputTokens" class="form-control" min="0" value="0">
        </div>
        <div class="col-md-4">
          <label class="form-label">Output Tokens</label>
          <input type="number" id="costOutputTokens" class="form-control" min="0" value="0">
        </div>
      </div>
      <button id="estimateCostBtn" class="btn btn-secondary mb-2">Estimate Cost</button>
      <div id="costEstimate" class="mb-2"></div>
      <p class="small text-muted">Estimates are approximate. See <a href="https://platform.openai.com/docs/pricing?latest-pricing=standard" target="_blank">OpenAI pricing</a> for current rates.</p>
    </section>

      <section id="season-context-section">
        <h2 class="h4">Season Contexts <small class="text-muted">(/season-contexts)</small></h2>
        <div class="mb-2">
          <label class="form-label">Team Name</label>
          <input id="scTeamName" class="form-control">
        </div>
        <div class="mb-2">
          <label class="form-label">Season Context</label>
          <textarea id="scText" class="form-control" rows="5"></textarea>
        </div>
        <div class="mb-2">
          <button id="scGenerateBtn" class="btn btn-warning me-2 mb-2">
            <i class="bi bi-stars"></i> Refresh via Perplexity
          </button>
          <button id="scGenerateChatGPTBtn" class="btn btn-primary mb-2">
            <i class="bi bi-stars"></i> Refresh via ChatGPT Search
          </button>
        </div>
        <div class="mb-2">
          <button id="newSeasonContextBtn" class="btn btn-secondary me-2">
            <i class="bi bi-file-earmark-plus"></i> New
          </button>
          <button id="saveSeasonContextBtn" class="btn btn-success">
            <i class="bi bi-save"></i> Save
          </button>
        </div>
        <div id="seasonContextStatus" class="text-success mb-2"></div>
        <h5 class="mt-3">Existing Season Contexts</h5>
        <ul id="seasonContextList" class="list-group"></ul>
      </section>

      <section id="system-prompts-section">
        <h2 class="h4">System Prompts <small class="text-muted">(/system-prompts)</small></h2>
        <div class="mb-2">
          <label class="form-label">Prompt Name</label>
          <input id="spName" class="form-control">
        </div>
        <div class="mb-2">
          <label class="form-label">Prompt Body</label>
          <textarea id="spText" class="form-control" rows="5"></textarea>
        </div>
        <div class="mb-2">
          <button id="newPromptBtn" class="btn btn-secondary me-2">
            <i class="bi bi-file-earmark-plus"></i> New
          </button>
          <button id="savePromptBtn" class="btn btn-success">
            <i class="bi bi-save"></i> Save
          </button>
        </div>
        <div id="spStatus" class="text-success mb-2"></div>
        <h5 class="mt-3">Existing Prompts</h5>
        <ul id="promptList" class="list-group"></ul>
      </section>

      <section id="pronunciations-section">
        <h2 class="h4">Pronunciations <small class="text-muted">(/pronunciations)</small></h2>
        <div class="mb-2">
          <button id="fetchPronBtn" class="btn btn-info mb-2">
            <i class="bi bi-download"></i> Fetch Pronunciations
          </button>
        </div>
        <div class="row g-2 mb-2">
          <div class="col"><input id="pronTerm" class="form-control" placeholder="Term"></div>
          <div class="col"><input id="pronPron" class="form-control" placeholder="Pronunciation"></div>
          <div class="col-auto"><button id="savePronBtn" class="btn btn-success">Save</button></div>
        </div>
        <ul id="pronListServer" class="list-group mb-2"></ul>
        <div id="pronStatus" class="text-success"></div>
      </section>
  </div>

  <script>
  (function(){
    // Front-end logic for interacting with the API. The functions below
    // correspond to the various endpoints exposed by the server.
      // --- Season Context UI ---
      const seasonContextList = document.getElementById('seasonContextList');
      const scTeamName = document.getElementById('scTeamName');
      const scText = document.getElementById('scText');
      const scStatus = document.getElementById('seasonContextStatus');
      const saveSeasonContextBtn = document.getElementById('saveSeasonContextBtn');
      const newSeasonContextBtn = document.getElementById('newSeasonContextBtn');
      const scGenerateBtn = document.getElementById('scGenerateBtn');
      const scGenerateChatGPTBtn = document.getElementById('scGenerateChatGPTBtn');
      let seasonContexts = [];
      let currentSeasonContextId = null;

      async function loadSeasonContexts() {
        try {
          const res = await fetch(`${apiBase()}/season-contexts`);
          const data = await res.json();
          seasonContexts = data.season_contexts || [];
          seasonContextList.innerHTML = seasonContexts.map(c => `
            <li class="list-group-item d-flex justify-content-between">
              <span>${c.team_name}</span>
              <div>
                <button class="btn btn-sm btn-primary me-2" data-edit="${c.id}"><i class="bi bi-pencil"></i></button>
                <button class="btn btn-sm btn-danger" data-del="${c.id}"><i class="bi bi-trash"></i></button>
              </div>
            </li>`).join('');
          const options = seasonContexts.map(c => `<option value="${c.id}">${c.team_name}</option>`).join('');
          const scriptSel = document.getElementById('scriptSeasonSelect');
          const epSel = document.getElementById('epSeasonSelect');
          if (scriptSel) scriptSel.innerHTML = options;
          if (epSel) epSel.innerHTML = options;
        } catch (e) {
          seasonContextList.innerHTML = '<li class="list-group-item text-danger">Error loading</li>';
        }
      }

      newSeasonContextBtn.onclick = () => {
        currentSeasonContextId = null;
        scTeamName.value = '';
        scText.value = '';
        scStatus.textContent = '';
      };

      saveSeasonContextBtn.onclick = withLoading(saveSeasonContextBtn, async () => {
        const team_name = scTeamName.value.trim();
        const season_context = scText.value.trim();
        if (!team_name || !season_context) {
          scStatus.textContent = 'Enter team name and season context.';
          scStatus.className = 'text-danger mb-2';
          return;
        }
        const method = currentSeasonContextId ? 'PUT' : 'POST';
        const url = currentSeasonContextId ? `${apiBase()}/season-contexts/${currentSeasonContextId}` : `${apiBase()}/season-contexts`;
        try {
          const res = await fetch(url, {
            method,
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ team_name, season_context })
          });
          if (!res.ok) throw new Error(res.statusText);
          currentSeasonContextId = null;
          scTeamName.value = '';
          scText.value = '';
          scStatus.textContent = 'Saved!';
          scStatus.className = 'text-success mb-2';
          await loadSeasonContexts();
        } catch (e) {
          scStatus.textContent = 'Error: ' + e.message;
          scStatus.className = 'text-danger mb-2';
        }
      });

      seasonContextList.onclick = async e => {
        const editId = e.target.closest('[data-edit]')?.dataset.edit;
        const delId = e.target.closest('[data-del]')?.dataset.del;
        if (editId) {
          const ctx = seasonContexts.find(x => x.id === editId);
          if (ctx) {
            currentSeasonContextId = ctx.id;
            scTeamName.value = ctx.team_name;
            scText.value = ctx.season_context;
            scStatus.textContent = '';
          }
        }
        if (delId && confirm('Delete this season context?')) {
          const btn = e.target.closest('button');
          await withLoading(btn, async () => {
            const res = await fetch(`${apiBase()}/season-contexts/${delId}`, { method: 'DELETE' });
            if (!res.ok) throw new Error(res.statusText);
            if (currentSeasonContextId === delId) {
              currentSeasonContextId = null;
              scTeamName.value = '';
              scText.value = '';
            }
            await loadSeasonContexts();
          })().catch(err => {
            scStatus.textContent = 'Error: ' + err.message;
            scStatus.className = 'text-danger mb-2';
          });
        }
      };

      scGenerateBtn.onclick = withLoading(scGenerateBtn, async () => {
        const team = scTeamName.value.trim();
        if (!team) {
          scStatus.textContent = 'Enter team name.';
          scStatus.className = 'text-danger mb-2';
          return;
        }
        scStatus.textContent = 'Generating…';
        scStatus.className = 'text-muted mb-2';
        try {
          const res = await fetch(`${apiBase()}/season-contexts/refresh`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ team_name: team })
          });
          if (!res.ok) throw new Error(res.statusText);
          const data = await res.json();
          currentSeasonContextId = data.id;
          scTeamName.value = data.team_name;
          scText.value = data.season_context || '';
          scStatus.textContent = 'Season context generated!';
          scStatus.className = 'text-success mb-2';
          await loadSeasonContexts();
        } catch (e) {
          scStatus.textContent = 'Error: ' + e.message;
          scStatus.className = 'text-danger mb-2';
        }
      });

      scGenerateChatGPTBtn.onclick = withLoading(scGenerateChatGPTBtn, async () => {
        const team = scTeamName.value.trim();
        if (!team) {
          scStatus.textContent = 'Enter team name.';
          scStatus.className = 'text-danger mb-2';
          return;
        }
        scStatus.textContent = 'Generating…';
        scStatus.className = 'text-muted mb-2';
        try {
          const res = await fetch(`${apiBase()}/season-contexts/refresh-chatgpt`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ team_name: team })
          });
          if (!res.ok) throw new Error(res.statusText);
          const data = await res.json();
          currentSeasonContextId = data.id;
          scTeamName.value = data.team_name;
          scText.value = data.season_context || '';
          scStatus.textContent = 'Season context generated!';
          scStatus.className = 'text-success mb-2';
          await loadSeasonContexts();
        } catch (e) {
          scStatus.textContent = 'Error: ' + e.message;
          scStatus.className = 'text-danger mb-2';
        }
      });

      document.addEventListener('DOMContentLoaded', loadSeasonContexts);

      // --- System Prompts UI ---
      const promptList = document.getElementById('promptList');
      const spName = document.getElementById('spName');
      const spText = document.getElementById('spText');
      const spStatus = document.getElementById('spStatus');
      const savePromptBtn = document.getElementById('savePromptBtn');
      const newPromptBtn = document.getElementById('newPromptBtn');
      let prompts = [];
      let currentPromptId = null;

      async function loadPrompts() {
        try {
          const res = await fetch(`${apiBase()}/system-prompts`);
          const data = await res.json();
          prompts = data.prompts || [];
          promptList.innerHTML = prompts.map(p => `
            <li class="list-group-item d-flex justify-content-between">
              <span>${p.name}</span>
              <div>
                <button class="btn btn-sm btn-primary me-2" data-edit="${p.id}"><i class="bi bi-pencil"></i></button>
                <button class="btn btn-sm btn-danger" data-del="${p.id}"><i class="bi bi-trash"></i></button>
              </div>
            </li>`).join('');
          const options = prompts.map(p => `<option value="${p.id}">${p.name}</option>`).join('');
          const scriptSel = document.getElementById('scriptPromptSelect');
          const epSel = document.getElementById('epPromptSelect');
          if (scriptSel) scriptSel.innerHTML = options;
          if (epSel) epSel.innerHTML = options;
        } catch (e) {
          promptList.innerHTML = '<li class="list-group-item text-danger">Error loading</li>';
        }
      }

      newPromptBtn.onclick = () => {
        currentPromptId = null;
        spName.value = '';
        spText.value = '';
        spStatus.textContent = '';
      };

      savePromptBtn.onclick = withLoading(savePromptBtn, async () => {
        const name = spName.value.trim();
        const prompt = spText.value.trim();
        if (!name || !prompt) {
          spStatus.textContent = 'Enter name and prompt.';
          spStatus.className = 'text-danger mb-2';
          return;
        }
        const method = currentPromptId ? 'PUT' : 'POST';
        const url = currentPromptId ? `${apiBase()}/system-prompts/${currentPromptId}` : `${apiBase()}/system-prompts`;
        try {
          const res = await fetch(url, {
            method,
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ name, prompt })
          });
          if (!res.ok) throw new Error(res.statusText);
          currentPromptId = null;
          spName.value = '';
          spText.value = '';
          spStatus.textContent = 'Saved!';
          spStatus.className = 'text-success mb-2';
          await loadPrompts();
        } catch (e) {
          spStatus.textContent = 'Error: ' + e.message;
          spStatus.className = 'text-danger mb-2';
        }
      });

      promptList.onclick = async e => {
        const editId = e.target.closest('[data-edit]')?.dataset.edit;
        const delId = e.target.closest('[data-del]')?.dataset.del;
        if (editId) {
          const p = prompts.find(x => x.id === editId);
          if (p) {
            currentPromptId = p.id;
            spName.value = p.name;
            spText.value = p.prompt;
            spStatus.textContent = '';
          }
        }
        if (delId && confirm('Delete this prompt?')) {
          const btn = e.target.closest('button');
          await withLoading(btn, async () => {
            const res = await fetch(`${apiBase()}/system-prompts/${delId}`, { method: 'DELETE' });
            if (!res.ok) throw new Error(res.statusText);
            if (currentPromptId === delId) {
              currentPromptId = null;
              spName.value = '';
              spText.value = '';
            }
            await loadPrompts();
          })().catch(err => {
            spStatus.textContent = 'Error: ' + err.message;
            spStatus.className = 'text-danger mb-2';
          });
        }
      };

      document.addEventListener('DOMContentLoaded', loadPrompts);

      // --- Pronunciations Test UI ---
      const fetchPronBtn = document.getElementById('fetchPronBtn');
      const savePronBtn = document.getElementById('savePronBtn');
      const pronTerm = document.getElementById('pronTerm');
      const pronPron = document.getElementById('pronPron');
      const pronListServer = document.getElementById('pronListServer');
      const pronStatus = document.getElementById('pronStatus');
      let serverPronMap = {};

      function renderServerPron(){
        pronListServer.innerHTML = Object.entries(serverPronMap).map(([k,v]) => `
          <li class="list-group-item d-flex justify-content-between">
            <span>${k} → ${v}</span>
            <button class="btn btn-sm btn-danger" data-del="${k}">x</button>
          </li>`).join('');
      }

      if (fetchPronBtn) fetchPronBtn.onclick = withLoading(fetchPronBtn, async () => {
        pronStatus.textContent = '';
        try {
          const res = await fetch(`${apiBase()}/pronunciations`);
          if (!res.ok) throw new Error(res.statusText);
          const data = await res.json();
          serverPronMap = data.pronunciations || {};
          renderServerPron();
        } catch (e) {
          pronStatus.textContent = 'Error: ' + e.message;
          pronStatus.className = 'text-danger mb-2';
        }
      });

      if (savePronBtn) savePronBtn.onclick = withLoading(savePronBtn, async () => {
        const term = pronTerm.value.trim();
        const pronunciation = pronPron.value.trim();
        if (!term || !pronunciation) {
          pronStatus.textContent = 'Enter term and pronunciation.';
          pronStatus.className = 'text-danger mb-2';
          return;
        }
        pronStatus.textContent = '';
        try {
          const method = serverPronMap[term] ? 'PUT' : 'POST';
          const res = await fetch(`${apiBase()}/pronunciations`, {
            method,
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ term, pronunciation })
          });
          if (!res.ok) throw new Error(res.statusText);
          const data = await res.json();
          if (data.success) {
            serverPronMap[term] = pronunciation;
            renderServerPron();
            pronTerm.value = '';
            pronPron.value = '';
            pronStatus.textContent = 'Saved!';
            pronStatus.className = 'text-success mb-2';
          } else {
            pronStatus.textContent = 'Failed.';
            pronStatus.className = 'text-danger mb-2';
          }
        } catch (e) {
          pronStatus.textContent = 'Error: ' + e.message;
          pronStatus.className = 'text-danger mb-2';
        }
      });

      pronListServer?.addEventListener('click', async e => {
        const term = e.target.closest('[data-del]')?.dataset.del;
        if (!term) return;
        if (!confirm(`Delete "${term}"?`)) return;
        const btn = e.target.closest('button');
        await withLoading(btn, async () => {
          const res = await fetch(`${apiBase()}/pronunciations/${encodeURIComponent(term)}`, { method: 'DELETE' });
          if (!res.ok) throw new Error(res.statusText);
          delete serverPronMap[term];
          renderServerPron();
        })().catch(err => alert('Delete failed: ' + err.message));
      });
const apiInput = document.getElementById('apiBase');
const openaiInput = document.getElementById('openaiKey');
const geminiInput = document.getElementById('geminiKey');
const perplexityInput = document.getElementById('perplexityKey');
const apiBase = () => apiInput.value.replace(/\/+$/, '');

function authHeaders() {
  const headers = {};
  if (openaiInput.value) headers['x-openai-key'] = openaiInput.value.trim();
  if (geminiInput.value) headers['x-gemini-key'] = geminiInput.value.trim();
  if (perplexityInput.value) headers['x-perplexity-key'] = perplexityInput.value.trim();
  return headers;
}

const originalFetch = window.fetch;
window.fetch = (input, init = {}) => {
  init.headers = { ...(init.headers || {}), ...authHeaders() };
  return originalFetch(input, init);
};

// Utility to show a spinner on a button while an async task runs
function withLoading(btn, fn) {
  return async function(...args) {
    const spinner = document.createElement('span');
    spinner.className = 'spinner-border spinner-border-sm ms-2';
    btn.disabled = true;
    btn.appendChild(spinner);
    try {
      return await fn.apply(this, args);
    } finally {
      btn.disabled = false;
      spinner.remove();
    }
  };
}

    // — Audio Files Handlers —
    // Fetch the list of uploaded audio files and render buttons
    async function refreshFiles(){
      const list = document.getElementById('fileList');
      list.innerHTML = '<li class="list-group-item">Loading…</li>';
      try {
        const res = await fetch(`${apiBase()}/audio-files`);
        const files = await res.json();
        if (!files.length) {
          list.innerHTML = '<li class="list-group-item">No files.</li>';
          return;
        }
        list.innerHTML = files.map(f => `
          <li class="list-group-item d-flex justify-content-between align-items-center">
            <span>${f.fileName}</span>
            <div>
              <button class="btn btn-sm btn-primary me-2" data-play="${f.fileName}">
                <i class="bi bi-play-fill"></i>
              </button>
              <button class="btn btn-sm btn-danger" data-delete="${f.fileName}">
                <i class="bi bi-trash"></i>
              </button>
            </div>
          </li>
        `).join('');
      } catch(e){
        list.innerHTML = `<li class="list-group-item text-danger">Error loading</li>`;
      }
    }

    document.getElementById('uploadBtn').onclick = withLoading(document.getElementById('uploadBtn'), async () => {
      const inp = document.getElementById('fileInput');
      if (!inp.files.length) return alert('Select a file');
      const file = inp.files[0];
      const form = new FormData();
      form.append('file', file);
      try {
        const res = await fetch(`${apiBase()}/audio-files`, {
          method: 'POST',
          body: form
        });
        if (!res.ok) throw new Error(res.statusText);
        inp.value = '';
        await refreshFiles();
      } catch(e){
        alert('Upload failed: ' + e.message);
      }
    });

    document.getElementById('refreshFilesBtn').onclick = withLoading(document.getElementById('refreshFilesBtn'), refreshFiles);

    document.getElementById('fileList').onclick = async e => {
      const play = e.target.closest('[data-play]')?.dataset.play;
      const del  = e.target.closest('[data-delete]')?.dataset.delete;
      if (play) {
        const p = document.getElementById('audioPlayer');
        p.src = `${apiBase()}/audio-files/${encodeURIComponent(play)}`;
        p.hidden = false;
        p.play();
      }
      if (del && confirm(`Delete "${del}"?`)) {
        const btn = e.target.closest('button');
        await withLoading(btn, async () => {
          const res = await fetch(`${apiBase()}/audio-files/${encodeURIComponent(del)}`, {
            method: 'DELETE'
          });
          if (!res.ok) throw new Error(res.statusText);
          document.getElementById('audioPlayer').hidden = true;
          await refreshFiles();
        })().catch(err => alert('Delete failed: ' + err.message));
      }
    };

    // — Text to Speech Logic —
    // Sends the prompt and selected voices to the /dialogue endpoint
      const pronunciationMap = {};
      const pronKey  = document.getElementById('pronounceKey');
      const pronVal  = document.getElementById('pronounceVal');
      const pronList = document.getElementById('pronounceList');
      const addPronBtn = document.getElementById('addPronounceBtn');

      function renderPronList() {
        if (!pronList) return;
        pronList.innerHTML = Object.entries(pronunciationMap)
          .map(([k,v]) => `<li class="list-group-item d-flex justify-content-between"><span>${k} → ${v}</span><button class="btn btn-sm btn-danger" data-del="${k}">x</button></li>`)
          .join('');
      }

      if (pronKey && pronVal && pronList && addPronBtn) {
        addPronBtn.onclick = () => {
          const k = pronKey.value.trim();
          const v = pronVal.value.trim();
          if (!k || !v) return;
          pronunciationMap[k] = v;
          pronKey.value = '';
          pronVal.value = '';
          renderPronList();
        };

        pronList.onclick = e => {
          const del = e.target.closest('[data-del]')?.dataset.del;
          if (del) { delete pronunciationMap[del]; renderPronList(); }
        };
      }

      const dlgBtnEl = document.getElementById('dlgBtn');
      dlgBtnEl.addEventListener('click', withLoading(dlgBtnEl, async () => {
        let prompt   = document.getElementById('ttsPrompt').value.trim();
        for (const [k,v] of Object.entries(pronunciationMap)) {
          prompt = prompt.split(k).join(v);
        }
        const s1Name   = document.getElementById('speaker1Name').value.trim();
        const s1Voice  = document.getElementById('speaker1Voice').value;
        const s2Name   = document.getElementById('speaker2Name').value.trim();
        const s2Voice  = document.getElementById('speaker2Voice').value;
        const model    = document.getElementById('voiceModel').value;
        if (!prompt) return alert('Enter a prompt');

        try {
          const res = await fetch(`${apiBase()}/dialogue`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              prompt,
              speaker1Name: s1Name,
              speaker1Voice: s1Voice,
              speaker2Name: s2Name,
              speaker2Voice: s2Voice,
              voiceContext: document.getElementById('voiceContext').value,
              model
            })
          });
        if (!res.ok) {
          let msg = res.statusText;
          try { const err = await res.json(); msg = err.error || msg; } catch {}
          throw new Error(msg);
        }

        const blob = await res.blob();
        const player = document.getElementById('dlgPlayer');
        player.src = URL.createObjectURL(blob);
        player.hidden = false;
        player.play();
      } catch (e) {
        alert('TTS failed: ' + e.message);
      }
    }));

    // — Latest Post —
    // Fetches the most recent STL City SC post via the proxy
    const fetchLatestBtn = document.getElementById('fetchLatestBtn');
    fetchLatestBtn.onclick = withLoading(fetchLatestBtn, async () => {
      const out = document.getElementById('latestPost');
      out.innerHTML = '<div>Loading…</div>';
      const pages = parseInt(document.getElementById('latestPages').value, 10) || 1;
      try {
        const res = await fetch(`${apiBase()}/stlcitysc/latest-post?pages=${pages}`);
        if (!res.ok) throw new Error(res.statusText);
        const data = await res.json();
        let posts = [];
        if (Array.isArray(data)) posts = data;
        else if (Array.isArray(data.items)) posts = data.items;
        else if (Array.isArray(data.posts)) posts = data.posts;
        else if (Array.isArray(data.docs)) posts = data.docs;
        else if (Array.isArray(data.data)) posts = data.data;
        out.innerHTML = posts.map(p => {
          const date = p.publish_date_iso || p.updated_date_iso || '';
          return `
            <div class="col-12">
              <div class="card">
                <div class="card-body">
                  <div class="form-check">
                    <input class="form-check-input ep-article-check" type="checkbox" value="${p.id}" id="chk-${p.id}">
                    <label class="form-check-label" for="chk-${p.id}">
                      <strong>${p.full_title || p.title || ''}</strong>
                      <span class="badge bg-secondary ms-2">${p.type}</span>
                      <small class="text-muted ms-2">${date}</small>
                    </label>
                  </div>
                  <pre class="mt-2 small">${(p.body || '').toString().substring(0,1000)}</pre>
                </div>
              </div>
            </div>`;
        }).join('');
        out.onchange = () => {
          const ids = Array.from(out.querySelectorAll('.ep-article-check:checked')).map(c => c.value);
          const joined = ids.join(',');
          document.getElementById('epArticleId').value = joined;
          // also populate scriptArticleId for podcast script
          const scriptInput = document.getElementById('scriptArticleId');
          if (scriptInput) scriptInput.value = joined;
        };
      } catch (e) {
        out.innerHTML = `<div class="text-danger">Error: ${e.message}</div>`;
      }
    });

    // — Podcast Script —
    // Generates a short script using the stored prompt
      const genScriptBtn = document.getElementById('generateScriptBtn');
      genScriptBtn.onclick = withLoading(genScriptBtn, async () => {
        const out = document.getElementById('podcastScript');
        out.textContent = 'Loading…';
        // Get Article IDs
        const idVal = document.getElementById('scriptArticleId').value.trim();
        const ids = idVal.split(/[,\s]+/).filter(Boolean);
        if (!ids.length) {
          out.textContent = 'Error: Enter an Article ID';
          return;
        }
        const payload = {
          articleIds: ids,
          podcast_name: document.getElementById('podcastName').value,
          team_name: document.getElementById('teamName').value,
          seasonContextId: document.getElementById('scriptSeasonSelect').value,
          tone: document.getElementById('tone').value,
          length_min: document.getElementById('lengthMin').value,
          custom_intro: document.getElementById('customIntro').value,
          custom_outro: document.getElementById('customOutro').value,
          promptId: document.getElementById('scriptPromptSelect').value
        };
        try {
          const res = await fetch(`${apiBase()}/stlcitysc/generate-script`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
          });
          if (!res.ok) throw new Error(res.statusText);
          const data = await res.json();
          out.textContent = data.script || JSON.stringify(data, null, 2);
        } catch (e) {
          out.textContent = 'Error: ' + e.message;
        }
      });

      const editScriptBtn = document.getElementById('editScriptBtn');
      editScriptBtn.onclick = withLoading(editScriptBtn, async () => {
        const out = document.getElementById('podcastScript');
        const instructions = document.getElementById('editInstructions').value.trim();
        if (!out.textContent.trim()) {
          out.textContent = 'Error: Generate a script first.';
          return;
        }
        if (!instructions) {
          out.textContent = 'Error: Enter edit instructions.';
          return;
        }
        try {
          const res = await fetch(`${apiBase()}/stlcitysc/edit-script`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ script: out.textContent, instructions })
          });
          if (!res.ok) throw new Error(res.statusText);
          const data = await res.json();
          out.textContent = data.script || out.textContent;
        } catch (e) {
          out.textContent = 'Error: ' + e.message;
        }
      });

      // — Episode Generation —
      // Create full episode audio, script, and transcript
      const genEpBtn = document.getElementById('generateEpisodeBtn');
      genEpBtn.onclick = withLoading(genEpBtn, async () => {
        const scriptOut = document.getElementById('episodeScript');
        const transcriptOut = document.getElementById('episodeTranscript');
        const player = document.getElementById('episodePlayer');
        const img = document.getElementById('episodeImage');
        const thumb = document.getElementById('episodeThumb');
        const progress = document.getElementById('episodeProgress');
        scriptOut.textContent = 'Loading…';
        transcriptOut.textContent = '';
        player.hidden = true;
        thumb.hidden = true;
        const idVal = document.getElementById('epArticleId').value.trim();
        const ids = idVal.split(/[,\s]+/).filter(Boolean);
        if (!ids.length) {
          scriptOut.textContent = 'Error: Enter an article ID';
          return;
        }
        const payload = {
          articleIds: ids,
          host_a: document.getElementById('epHostAName').value,
          host_b: document.getElementById('epHostBName').value,
          voice_a: document.getElementById('epHostAVoice').value,
          voice_b: document.getElementById('epHostBVoice').value,
          prompt_tweak: document.getElementById('epPromptTweak').value,
          voice_context: document.getElementById('epVoiceContext').value,
          voice_model: document.getElementById('epVoiceModel').value,
          promptId: document.getElementById('epPromptSelect').value,
          seasonContextId: document.getElementById('epSeasonSelect').value
        };
        progress.style.display = 'block';
        try {
          const res = await fetch(`${apiBase()}/stlcitysc/generate-episode`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
          });
          if (!res.ok) {
            let msg = res.statusText;
            try { const err = await res.json(); msg = err.error || msg; } catch {}
            throw new Error(msg);
          }
          const data = await res.json();
          scriptOut.textContent = data.script || '';
          if (data.audioUrl) {
            player.src = data.audioUrl;
            player.hidden = false;
            player.play();
          } else if (data.audio) {
            player.src = `data:audio/wav;base64,${data.audio}`;
            player.hidden = false;
            player.play();
          }
          if (data.imageUrl) {
            img.src = data.imageUrl;
            thumb.hidden = false;
          } else if (data.image) {
            img.src = `data:image/png;base64,${data.image}`;
            thumb.hidden = false;
          }
          if (data.transcript)
            transcriptOut.textContent = JSON.stringify(data.transcript, null, 2);
        } catch (e) {
          scriptOut.textContent = 'Error: ' + e.message;
        } finally {
          progress.style.display = 'none';
        }
      });

      // — Transcript Fetch —
      // Retrieve an existing transcript for the given file name
      const getTranscriptBtn = document.getElementById('getTranscriptBtn');
      getTranscriptBtn.onclick = withLoading(getTranscriptBtn, async () => {
        const name = document.getElementById('transcriptFile').value.trim();
        if (!name) return alert('Enter a file name');
        const out = document.getElementById('transcriptOut');
        out.textContent = 'Loading…';
        try {
          const res = await fetch(`${apiBase()}/transcripts/${encodeURIComponent(name)}`);
          if (!res.ok) throw new Error(res.statusText);
          const data = await res.json();
          out.textContent = JSON.stringify(data, null, 2);
        } catch (e) {
          out.textContent = 'Error: ' + e.message;
        }
      });

      // Upload a local file and request a new transcript
      const uploadTranscriptBtn = document.getElementById('uploadTranscriptBtn');
      uploadTranscriptBtn.onclick = withLoading(uploadTranscriptBtn, async () => {
        const inp = document.getElementById('localTranscriptFile');
        if (!inp.files.length) return alert('Select a file');
        const file = inp.files[0];
        const form = new FormData();
        form.append('file', file);
        const out = document.getElementById('transcriptOut');
        out.textContent = 'Loading…';
        try {
          const res = await fetch(`${apiBase()}/transcripts`, {
            method: 'POST',
            body: form
          });
          if (!res.ok) throw new Error(res.statusText);
          const data = await res.json();
          out.textContent = JSON.stringify(data, null, 2);
        } catch (e) {
          out.textContent = 'Error: ' + e.message;
        }
      });

      // — Intro/Outro Mixer —
      const mixBtn = document.getElementById('mixBtn');
      mixBtn.onclick = withLoading(mixBtn, async () => {
        const intro = document.getElementById('introFile').files[0];
        const main  = document.getElementById('mainFile').files[0];
        const outro = document.getElementById('outroFile').files[0];
        if (!intro || !main || !outro) return alert('Select all files');
        const form = new FormData();
        form.append('intro', intro);
        form.append('audio', main);
        form.append('outro', outro);
        const player = document.getElementById('mixPlayer');
        try {
          const res = await fetch(`${apiBase()}/intro-outro`, { method: 'POST', body: form });
          if (!res.ok) throw new Error(res.statusText);
          const blob = await res.blob();
          player.src = URL.createObjectURL(blob);
          player.hidden = false;
          player.play();
        } catch (e) {
          alert('Mix failed: ' + e.message);
        }
      });

      // — Thumbnail Generator —
      const genThumbBtn = document.getElementById('generateThumbBtn');
      genThumbBtn.onclick = withLoading(genThumbBtn, async () => {
        const prompt = document.getElementById('thumbPrompt').value.trim();
        if (!prompt) return alert('Enter a prompt');
        const img = document.getElementById('thumbImage');
        img.hidden = true;
        try {
          const res = await fetch(`${apiBase()}/thumbnail`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ prompt })
          });
          if (!res.ok) throw new Error(res.statusText);
          const data = await res.json();
          img.src = data.url;
          img.hidden = false;
        } catch (e) {
          alert('Image generation failed: ' + e.message);
        }
      });

      const genThumbFromScriptBtn = document.getElementById('generateThumbFromScriptBtn');
      genThumbFromScriptBtn.onclick = withLoading(genThumbFromScriptBtn, async () => {
        const script = document.getElementById('thumbScript').value.trim();
        if (!script) return alert('Paste a script');
        const img = document.getElementById('thumbImage');
        img.hidden = true;
        try {
          const res = await fetch(`${apiBase()}/thumbnail-from-script`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ script })
          });
          if (!res.ok) throw new Error(res.statusText);
          const data = await res.json();
          img.src = data.url;
          img.hidden = false;
        } catch (e) {
          alert('Image generation failed: ' + e.message);
        }
      });

      const listThumbsBtn = document.getElementById('listThumbsBtn');
      listThumbsBtn.onclick = withLoading(listThumbsBtn, async () => {
        try {
          const res = await fetch(`${apiBase()}/thumbnails`);
          if (!res.ok) throw new Error(res.statusText);
          const data = await res.json();
          const list = document.getElementById('thumbList');
          list.innerHTML = '';
          data.files.forEach(name => {
            const img = document.createElement('img');
            img.src = `${apiBase()}/thumbs/${encodeURIComponent(name)}`;
            img.alt = name;
            img.className = 'img-thumbnail me-2 mb-2';
            img.style.maxHeight = '150px';
            list.appendChild(img);
          });
        } catch (e) {
          alert('List failed: ' + e.message);
        }
      });

      const deleteThumbBtn = document.getElementById('deleteThumbBtn');
      deleteThumbBtn.onclick = withLoading(deleteThumbBtn, async () => {
        const name = document.getElementById('thumbFileName').value.trim();
        if (!name) return alert('Enter file name');
        try {
          const res = await fetch(`${apiBase()}/thumbnail/${encodeURIComponent(name)}`, { method: 'DELETE' });
          if (!res.ok) throw new Error(res.statusText);
          alert('Deleted');
        } catch (e) {
          alert('Delete failed: ' + e.message);
        }
      });

      const updateThumbBtn = document.getElementById('updateThumbBtn');
      updateThumbBtn.onclick = withLoading(updateThumbBtn, async () => {
        const name = document.getElementById('thumbFileName').value.trim();
        const prompt = document.getElementById('thumbPrompt').value.trim();
        if (!name || !prompt) return alert('Enter file name and prompt');
        const img = document.getElementById('thumbImage');
        img.hidden = true;
        try {
          const res = await fetch(`${apiBase()}/thumbnail/${encodeURIComponent(name)}`, {
            method: 'PUT',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ prompt })
          });
          if (!res.ok) throw new Error(res.statusText);
          const data = await res.json();
          img.src = data.url;
          img.hidden = false;
        } catch (e) {
          alert('Update failed: ' + e.message);
        }
      });

    // — ChatGPT —
    // Send a free-form prompt to the /chat endpoint
    const sendChatBtn = document.getElementById('sendChatBtn');
    sendChatBtn.onclick = withLoading(sendChatBtn, async () => {
      const prompt = document.getElementById('chatPrompt').value.trim();
      if (!prompt) return alert('Enter a prompt');
      const temp = parseFloat(document.getElementById('optTemp').value);
      const maxT = parseInt(document.getElementById('optMax').value, 10);
      const out  = document.getElementById('chatReply');
      out.textContent = 'Thinking…';
      try {
        const res = await fetch(`${apiBase()}/chat`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            prompt,
            options: { temperature: temp, max_tokens: maxT }
          })
        });
        if (!res.ok) throw new Error(res.statusText);
        const data = await res.json();
        out.textContent = data.reply;
      } catch (e) {
        out.textContent = 'Error: ' + e.message;
      }
    });

    // — Cost Estimator —
    const estimateBtn = document.getElementById('estimateCostBtn');
    if (estimateBtn) {
      const costOut = document.getElementById('costEstimate');
      const modelSel = document.getElementById('costModel');
      const inTok = document.getElementById('costInputTokens');
      const outTok = document.getElementById('costOutputTokens');
      const MODEL_RATES = {
        'gpt-4o': { input: 0.005, output: 0.015 },
        'gpt-4o-mini': { input: 0.00015, output: 0.0006 }
      };
      estimateBtn.onclick = () => {
        const model = modelSel.value;
        const rates = MODEL_RATES[model];
        const tIn = parseInt(inTok.value, 10) || 0;
        const tOut = parseInt(outTok.value, 10) || 0;
        const cost = (tIn * rates.input + tOut * rates.output) / 1000;
        costOut.textContent = `Estimated cost: $${cost.toFixed(4)}`;
      };
    }

    // initial load - display any existing audio files
    document.addEventListener('DOMContentLoaded', refreshFiles);
      // Optionally, auto-fetch season context on load
      document.addEventListener('DOMContentLoaded', () => {
        if (fetchSeasonContextBtn) fetchSeasonContextBtn.click();
        if (fetchPronBtn) fetchPronBtn.click();
      });
  })();
  </script>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>

<section id="readme" class="mt-5">
<h2 class="h4">Project README</h2>
<div class="markdown">
<h1>ARS Testing API</h1>

<p>This project provides an Express based API for storing audio files, generating text-to-speech dialogue, interacting with ChatGPT, and producing STL City SC podcast episodes. A minimal front end for manual testing lives in <code>Frontend/index.html</code>.</p>

<h2>Deployment Guide</h2>

<h3>Prerequisites</h3>

<ul>
<li>Node.js 18 or later</li>
<li>A PostgreSQL database (Render, Azure Database for PostgreSQL, etc.)</li>
<li>Accounts/keys for external services:</li>
</ul>
<p>  - <code>OPENAI_API_KEY</code></p>
<p>  - <code>GEMINI_API_KEY</code></p>
<p>  - <code>STLCITYSC_TOKEN</code></p>
<ul>
<li>Optional persistent storage if the host filesystem is temporary.</li>
</ul>

<h3>Clone and configure</h3>

<pre><code>
git clone https://github.com/Knooblegooble/ARSTesting.git
cd ARSTesting
</code></pre>

<p>Create a <code>.env</code> file in the project root:</p>

<pre><code>
PORT=3000
DATABASE_URL=postgres://user:pass@host:5432/db
SERVER_URL=https://your-domain
OPENAI_API_KEY=sk-...
GEMINI_API_KEY=...
STLCITYSC_TOKEN=...
</code></pre>

<h3>Run locally</h3>

<pre><code>
npm install
npm start
</code></pre>

<p>The server listens on the port specified by <code>PORT</code> (defaults to <code>3000</code>).</p>

<h3>Deploy to Render</h3>

<ol>
<li>Create a PostgreSQL database on Render.</li>
<li>Create a new Web Service from this repository or use the included <code>render.yaml</code> blueprint.</li>
<li>In the service settings, add the environment variables shown above. For <code>DATABASE_URL</code>, use the internal connection string from the Render database.</li>
<li>Set build command to <code>npm install</code> and start command to <code>npm start</code>.</li>
<li>Add a persistent disk if you need to retain uploaded files.</li>
</ol>

<h3>Deploy to other platforms (e.g., Azure)</h3>

<ol>
<li>Provision a Node.js environment (Azure App Service, AWS Elastic Beanstalk, etc.).</li>
<li>Provision a PostgreSQL database and note its connection string.</li>
<li>Deploy the repository code to the environment (via Git, zip upload, or container).</li>
<li>Configure the same environment variables as above.</li>
<li>Install dependencies and start the app with <code>npm install</code> and <code>npm start</code> (or the platform's equivalent).</li>
<li>Ensure the service has persistent storage for uploaded audio and images or modify the code to use cloud storage.</li>
</ol>

<h2>Endpoints</h2>

<p>All routes are relative to the server base URL (e.g. <code>http://localhost:3000</code>).</p>

<h3>Audio Storage</h3>

<p><code>GET /audio-files</code></p>
<p>: List uploaded files.</p>

<p><code>POST /audio-files</code></p>
<p>: Upload an <code>.mp3</code> or <code>.wav</code> file using <code>multipart/form-data</code> (<code>file</code> field). Returns <code>{ message: &amp;quot;Uploaded&amp;quot; }</code>.</p>

<p><code>GET /audio-files/:fileName</code></p>
<p>: Stream a stored file with HTTP range support.</p>

<p><code>DELETE /audio-files/:fileName</code></p>
<p>: Remove a stored file.</p>

<h3>Text to Speech</h3>

<p><code>POST /dialogue</code></p>
<p>: Generate multi‑speaker audio from a prompt. Body fields:</p>
<p>  - <code>prompt</code> – text to speak</p>
<p>  - <code>speaker1Name</code>, <code>speaker1Voice</code></p>
<p>  - <code>speaker2Name</code>, <code>speaker2Voice</code></p>
<p>  - <code>voiceContext</code> – optional preamble describing how to read the text (defaults to &quot;Read aloud in a charismatic, fun, sports podcast tone.&quot;)</p>
<p>  - <code>model</code> – optional voice model (<code>gemini-2.5-flash-preview-tts</code> default or <code>gemini-2.5-pro-preview-tts</code>)</p>
<p>  Returns raw audio (<code>audio/wav</code> or other type returned by Gemini).</p>

<h3>ChatGPT Proxy</h3>

<p><code>POST /chat</code></p>
<p>: Forward a prompt to ChatGPT. Body:</p>
<p>  <code></code>`json</p>
<p>  { &quot;prompt&quot;: &quot;Hello&quot;, &quot;options&quot;: { &quot;temperature&quot;: 0.7, &quot;max_tokens&quot;: 300 } }</p>
<p>  <code></code>`</p>
<p>  Returns <code>{ &amp;quot;reply&amp;quot;: &amp;quot;...&amp;quot; }</code>.</p>

<h3>Pronunciations</h3>

<p><code>GET /pronunciations</code></p>
<p>: List all stored pronunciation overrides.</p>

<p><code>POST /pronunciations</code></p>
<p>: Add a new term/pronunciation pair. Body <code>{ &quot;term&quot;: &quot;Foo&quot;, &quot;pronunciation&quot;: &quot;Foh&quot; }</code>.</p>

<p><code>PUT /pronunciations</code></p>
<p>: Update an existing term. Body <code>{ &quot;term&quot;: &quot;Foo&quot;, &quot;pronunciation&quot;: &quot;Foh&quot; }</code>.</p>

<p><code>DELETE /pronunciations/:term</code></p>
<p>: Remove a stored pronunciation by term.</p>

<h3>Season Context</h3>

<p><code>GET /season-contexts</code></p>
<p>: List all stored season contexts.</p>

<p><code>POST /season-contexts</code></p>
<p>: Add a new season context. Body <code>{ &quot;team_name&quot;: &quot;Saint Louis City SC&quot;, &quot;season_context&quot;: &quot;...&quot; }</code>.</p>

<p><code>GET /season-contexts/:id</code></p>
<p>: Retrieve a single season context by id.</p>

<p><code>PUT /season-contexts/:id</code></p>
<p>: Replace the existing season context.</p>

<p><code>POST /season-contexts/refresh</code></p>
<p>: Generate and save a fresh summary for a team. Body <code>{ &quot;team_name&quot;: &quot;Saint Louis City SC&quot; }</code>.</p>

<p><code>POST /season-contexts/refresh-chatgpt</code></p>
<p>: Generate and save a fresh summary via ChatGPT search. Body <code>{ &quot;team_name&quot;: &quot;Saint Louis City SC&quot; }</code>.</p>

<p><code>DELETE /season-contexts/:id</code></p>
<p>: Remove a stored season context.</p>

<p><code>GET /new-season-context</code></p>
<p>: Legacy endpoint that generates a summary via <code>team_name</code> query parameter.</p>

<h3>System Prompts</h3>

<p><code>GET /system-prompts</code></p>
<p>: List all stored prompts.</p>

<p><code>POST /system-prompts</code></p>
<p>: Add a new prompt. Body <code>{ &quot;name&quot;: &quot;Default&quot;, &quot;prompt&quot;: &quot;...&quot; }</code>.</p>

<p><code>GET /system-prompts/:id</code></p>
<p>: Retrieve a single prompt by id.</p>

<p><code>PUT /system-prompts/:id</code></p>
<p>: Replace the name and text of an existing prompt.</p>

<p><code>DELETE /system-prompts/:id</code></p>
<p>: Remove a prompt.</p>

<p><code>GET /system-prompt</code></p>
<p>: Legacy endpoint returning the first prompt in the list.</p>

<p><code>POST /system-prompt</code></p>
<p>: Legacy endpoint replacing the first prompt. Body <code>{ &quot;system_prompt&quot;: &quot;...&quot; }</code>.</p>

<h3>STL City SC Podcast</h3>

<p><code>GET /stlcitysc/latest-post</code></p>
<p>: Fetch recent articles. Optional query <code>pages</code> controls how many pages of results to fetch.</p>

<p><code>POST /stlcitysc/generate-script</code></p>
<p>: Generate a podcast script from one or more articles. Provide <code>articleId</code> or <code>articleIds</code> along with optional customization fields such as <code>podcast_name</code>, <code>team_name</code>, <code>tone</code>, <code>length_min</code>, <code>season_context</code>, <code>custom_intro</code>, <code>custom_outro</code>, <code>announcements</code>, and <code>prompt_tweak</code>. Returns <code>{ &amp;quot;script&amp;quot;: &amp;quot;...&amp;quot; }</code>.</p>

<p><code>POST /stlcitysc/edit-script</code></p>
<p>: Apply revision instructions to an existing script. Body <code>{ &quot;script&quot;: &quot;...&quot;, &quot;instructions&quot;: &quot;shorten&quot; }</code>.</p>

<p><code>POST /stlcitysc/generate-episode</code></p>
<p>: Produce an episode in one‑shot. Accepts <code>articleId</code> or <code>articleIds</code> plus the same customization options as above along with host/voice selections. The optional <code>voice_context</code> field lets you adjust how Gemini reads the script (defaults to &quot;Read aloud in a charismatic, fun, sports podcast tone.&quot;) and <code>voice_model</code> chooses between <code>gemini-2.5-flash-preview-tts</code> (default) and <code>gemini-2.5-pro-preview-tts</code>. Returns <code>{ script, audio, audioUrl, transcript }</code> where <code>audio</code> is base64 encoded and <code>audioUrl</code> points to the stored file. The <code>transcript</code> object now includes this same <code>audioUrl</code> for convenience.</p>



<h3>Intro/Outro Mixing</h3>

<p><code>POST /intro-outro</code></p>
<p>: Combine an intro clip, main audio, and outro clip into a single track. Upload all three files as <code>intro</code>, <code>audio</code>, and <code>outro</code> fields. Returns the merged WAV.</p>

<h3>Thumbnails</h3>

<p><code>POST /thumbnail</code></p>
<p>: Generate a thumbnail image from a text prompt using the OpenAI <code>gpt-image-1</code> model. If that model is unavailable, the server automatically falls back to <code>dall-e-3</code>. Returns <code>{ url, base64 }</code> where <code>url</code> points to the stored file.</p>

<p><code>POST /thumbnail-from-script</code></p>
<p>: Generate a thumbnail image from a podcast script. Provide <code>{ &amp;quot;script&amp;quot;: &amp;quot;...&amp;quot; }</code> and the server will first ask ChatGPT to craft an image prompt using the script and the instruction &quot;Create an image prompt describing the podcast episode thumbnail for the above podcast. Include in the prompt the text shown on the thumbnail: &#x27;City Minute Podcast&#x27;&quot;. That prompt is then used with <code>gpt-image-1</code>, falling back to <code>dall-e-3</code> if needed, and the resulting image is stored locally and returned as <code>{ url, base64, prompt }</code>.</p>

<p><code>GET /thumbnails</code></p>
<p>: List all generated thumbnail file names.</p>

<p><code>GET /thumbnail/:fileName</code></p>
<p>: Retrieve a specific thumbnail&#x27;s data (<code>{ url, base64 }</code>).</p>

<p><code>PUT /thumbnail/:fileName</code></p>
<p>: Regenerate an existing thumbnail with a new prompt.</p>

<p><code>DELETE /thumbnail/:fileName</code></p>
<p>: Remove a stored thumbnail.</p>

<h3>Transcripts</h3>

<p><code>POST /transcripts</code></p>
<p>: Transcribe an uploaded audio file (<code>file</code> field) using OpenAI Whisper. Returns a structured JSON transcript.</p>

<p><code>GET /transcripts/:fileName</code></p>
<p>: Retrieve (or create on demand) the transcript for a previously uploaded file.</p>

<h2>Postman Collection</h2>

<p>A ready‑to‑use Postman collection is provided in <code>postman_collection.json</code>. Import this file into Postman and set the collection variable <code>baseUrl</code> to the address where the server is running. The collection&#x27;s root documentation is synced with this README.</p>

<h2>Frontend Tester</h2>

<p>Open <code>Frontend/index.html</code> in a browser for a simple interface that exercises the above endpoints.</p>

</div>
</section>
</body>
</html>
